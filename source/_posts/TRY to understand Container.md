---
title: TRY to understand Container
date: 2024-10-26 23:00:47
tags:
---
# Start with Shell

We can use `ps` command to check the process information in the host.
The process with ID 1 is `sbin/init` and this init process createes another process called `systemed`, its function is to control other processes. Under which, it includes `sshd` which is used to create different Shell for different users. 

In the host there is a `sshd` process. Each time a new user connects to the host, a Shell process will be createed and the Shell executes the user's command.

Following is a simple Shell example
```c
int main (void) {
	static char buf[100]; 
	// read the cmd
	while (getcmd(buf, sizeof(buf)) >= 0) {
		// if fork return 0 indicate that we are in the child process 
		 if (fork() == 0) {
		  runcmd(persecmd(buf)); 
		  }
		// otherwise, we are in the parent process and and wait for the next command
		  wait(); 
	} 
}

void runcmd(struct cmd *cmd){
	...
	struct execcmd ecmd = (struct execcmd*)cmd;
	...
	exec(ecmd->argv[0],ecmd->argv);
}
```
``
All these processes are organized like a tree. And it is similar in folder system.
We can use `tree` command to find out.

# Don't move my document , Chroot
Linux 0.01 has already support the following function, that different users(or we say different process) could reach differnt 'root' direction position. These root here are local variable, which is differet than the 'real' root in the host.
These user specific root value is stored in the struct task_struct.
In oder to change this root value, the kern provide a function called `chroot` (change root)
Shell and glibc have the same function , which can be looked up using `man`

chroot()  changes the root directory of the calling process to that specified in path.  This directory will be used for pathnames beginning with /.  The root directory is inherited by all children of the calling process.

![Chroot](/pics/chroot.png)

example:
```bash
mkdir empty
#copy all the ~/bin/bash and ~/lib or ~/lib64 to this empty folder
sudo chroot empty
#chroot will using the empty as root and call the bash in the empty
```

# Wired mount

In order to copy all the files and lib to realise a usable root for user. We could use 'busybox', which is a package of direction that can be used as a normal user root.

## File system

> /proc 
It include all the process information, **pseudo** filesystem. It provide a interface with the Kernal. Just like the normal file system.

we can check the file system type with command `df`. 
Example

```bash
df -hT /
Filesystem     Type  Size  Used Avail Use% Mounted on
/dev/sdc       ext4 1007G   19G  938G   2% /
```
From the response, it shows that the file system / is loaded from /dev/sdc and resolute as ext4 file and show as a tree to the user.

Now, we try to mount the current file system in `\`in a non-sense new folder `heihei`

```bash
sudo mount -t ext4 /dev/sdc /heihei

ls heihei
bin  boot  dev  empty  etc  heihei  home  init  lib  lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  sys  tmp  usr  var
```

the decription from man explain this clearly. After attaching the file system tree to specific directory, the whole file system can be reached using this vertual interface. (in the meanwhile file entities are still in the original device)
```bash
man mount

DESCRIPTION
       All files accessible in a Unix system are arranged in one big tree, the file hierarchy, rooted at /. These files can be spread out over several devices. The mount command serves to attach the filesystem found on some device to the big file tree. Conversely, the umount(8) command will detach it again. The filesystem is used to control how data is stored on the device or provided in a virtual way by network or other services.

       The standard form of the mount command is:

          mount -t type device dir
``` 

**In this way, we can access the same file system or /proc pseudo file system in different user view.**

# Visual trick of namespace
In Linux nsproxy is a attribute in the task_structure of the processes, it help to ideitify the processes which are belong to different namespace, so that different user could only see the process which belong to their own namespace. 

There are 3 system call could change the name space:
`clone()` createe a new process and by passing a flag to decide if redirect to the new namespce.
`unshare()` detach process to current namespace
`setns()`add the process to a new namespace
![NEWNS](/pics/NEWNS.jpg)
**Change of namespace can only happen when a new process is createed. And each process has only one namespace.** 
In the Kernel there is a init_nsproxy, each process generated by init in this namespce.After that all the child process will in herit from its father process namespace.

## Using clone to realise UTS namespace

`man namespaces` to check all the possible new namespaces.
```c
clone(child,malloac(4096)+4096, CLONE_NEWUTS | SIGCHLD,argv)
```
1. Child: child process start with child method;
2. Set 4k stack for the child process;
3. Process mask to indicate which behavior will be herit from father process, `SIGCHLD` means when child process stops, send out a SIGCHLD signal to father process.
4. Parameter for the child process

*When excute the code generated by this file, could need a super user access.*


Similary, we can apply all the namspace isolation:
```c
int flags = CLONE_NEWUTS|CLONE_NEWPID|CLONE_NEWNS|CLONE_NEWNET|CLONE_NEWIPC;
int pid = clone(child, malloac(4096)+4096, flags|SIGCHLD, argv);
```

For the mount operation need to be also set as private, so that the mount and umount operation of user won't affect the host. (In extrame situation, when the proc of host and user is exact the same, mount and umount operation in the user container will affect the host.)

# Stop the resource preemption

When the resource not in control, one user of container could preempt to much resource , so that the other users can not use anymore. In oder to stop the unexpected preemption, we need to control the resource in the system.

cgroup - Linux Control Group is used for limiting , recording or isolating the resources , which are assigned to sepecific process group.
It is designed as a pseudo file system, which can control the process group by write or read the corresponding file system.

Example:
```bash
# create a cgroup in the cpu directory
mkdir /sys/fs/cgroup/cpu/hydocker

# add specific process into the cgroup
echo 4620 > /sys/fs/cgroup/cpu/hydocker/tasks

# limit 50% of CPU can be assigned to this process
echo 50000 > /sys/fs/cgroup/cpu/hydocker/cpu.cfs_quota_us

# limit the RAM as 2G
echo 2g > /sys/fs/cgroup/memory/hydocker/memory.limit_in_bytes

# check specific process is belong to which cgroup
cat /proc/24241/cgroup

# check process status
cat /process/24241/stat

```
cgroup is a large file system , we can use following command to check which subsystems it has.

```bash
# list all the subsystem
lssubsys -am
```

# A bridge to the world

A host can only get connection to the network when it is correctly setted.
A container through net namespace to isolate it from host.(CLONE_NEWNET)

1.  Open local network
	`ip link set lo up`

2. Connect to the outside

2.1 Host  mode

In the host and container , add veth node sperately, and set corrsponding IP. (in the pic. "veth-container" and "veth-host") , add the ip of veth-host as default gateway.  (NAT may also needed to be connect to the outside network.)
![hostmode](/pics/hostmode.png)
2.2 Bridge mode

when there are many container, bridge is more suitable. 
Add a bridge (for example: br0) and connect the veth-host (here veth1 ) to the bridge. When all the other container connected to same bridge, they can communicate with each other. 
(Bridge is similar as switch)
![bridge](/pics/bridge.png)
## Net basic
OSI model (All People Seems To Need Data Processing)
![OSI](/pics/OSI.png)

### Hub
Hub is identified as Phsical layer. It is a broadcast mode.
Each device which is connected to a hub, has a *Mac Address*. 
Data package has a data-link head, it include source and target MAC address.  So that any device will know , if this data package is sent for it.
![hub](/pics/Hub.png)

### Switch
Switch is located Data Link layer. It has addtional a MAC address table. For example , Device B MAC` bb-bb-bb-bb-bb `port mapping to *Port 2*, when other device want to send data to it, then it just through port 2 to device B.  This kind of network is so called **Ethenet**.
![siwtch](/pics/switch.png)

### Router
When many Switches connected to each other , make it hard to maintain the Address list. We use router to transfer the data. Router is belong to the **Network** layer. Each port in the router has a unique MAC address.

> MAC address
> MAC address has 48 bit (6 byte), the first 24bit is a hardware maker identification, the next 24 bit is assigned by the makers. MAC is like personal ID, it is unique for each one. However it is so fixed that can bearly directly used in the router.  Because each subnet could has many differnt hardware maker, make it impossible to send out in one router port. 


>IP address
>In oder to solve the problem mensioned above, we use IP address for each device in the subnet. IP, unlike MAC, can be configured on demance for each device.

![IP](/pics/Router_IP.png)

Now, we need to add a Network-head after the data-link head to the data package. When 2 devices are not in the same subnet, then the data package must through router to be delivered. Otherwise, them can just use switch. 

> **How to judge if 2 devices in the same subnet ?**
> using Subnet Mask. 
> Example. set subnet mask as 255.255.255.0
> Device A IP = 192.168.0.1
> Device B IP = 192.168.0.2
> Device C IP = 192.168.1.1
> when these IP bitand with mask , A and B will has the same resalt 192.168.0 , they are in the same subnet.
> CIDR notation:
> 192.168.0.0(255.255.255.0) can also expressed as 192.168.0.0/24  
> /24 means first 24 bit is the network prefix, the last 8bit are used to identifying hosts in the network.

> **How to send A to C ?**
> By calculate subnt mask, we know A and C are not in the same subnet, then A will send the data package to the *default getway* . which here is the 192.168.0.254. The other works will leave to the router to transfer the datapackage.

> [! caution]
> Network layer actually can not deliver data package itself, delivering is realised in th Datalink layer (using MAC address through switches.)
> 3 important table:
> 1. MAC address table (mapping MAC address with switch ports)
> 2. Routing table (mapping IP with router port)
> 3. ARP cache table (through arp protocal to complete)

### Data packaging sending 
Host view:
1.  Get target IP address
2.  Using subnet mask to judge if in the same subnet
3.  IF in the same subnet, acquire the target MAC using ARP table, and send out.(through swtich)
4.  IF not in the same subnet, acquire the default gateway MAC using ARP table

Swith view:
1.  Get a datapackage with datalink head with MAC.
2.  Cheking the MAC address table
3.  IF MAC is known, send out to the coresponding port
4. IF MAC is unknown, broadcast.

Router view:
1.  Get a datapackage with Network Head with IP
2.  Checking routing table mapping 
3.  Send out with the IP corrsponding port.
4.  IF can not find the IP -port  mapping ,feedback unreachable.


# Stand alone together

In the above content we isolate the container and then connect to the world outside the container. 
Now we try to createe more container for different users.
It is easy to come to the idea that we seperate the original Image with container, and each time we createe a container process, then just copy one from the image, and give the container a unique name , so that next time we can reenter the same container and carry on the work.

However, when we copy image each time to generate a new container,  it will rapidly consume the space , and in most of the time, they share a lot of same files between 2 different container. 


## UnionFS

**UnionFS** is a filesystem service that allows multiple directories (branches) to be "merged" into a single virtual filesystem. The core idea of UnionFS is to overlay different filesystem layers, allowing files from multiple sources to appear in a single directory structure, even though they might reside on separate physical or logical filesystems.

Key Features of UnionFS:

1. **Layered Structure**:
    - UnionFS operates by stacking directories (or branches) on top of each other. 
2. **File Merging**:
    - If a file exists in multiple layers, UnionFS decides which version to display based on the layer's priority. Typically, files in higher-priority layers override those in lower-priority layers.
3. **Writable Layer**:
    - UnionFS usually has a writable layer at the top. When a file in a read-only layer is modified, the modified file is written to the writable layer, allowing the system to maintain an illusion of file modification without altering the lower, read-only layers.
4. **Copy-on-Write (COW)**:
    - When modifying a file in a read-only layer, UnionFS can perform a "copy-on-write" operation, where the file is copied to the writable layer before the changes are made.

Example: the following example can used to check the principle mentioned above.
Do some change to the merge folder , it will update with the upper folder. 
```bash
$ tree .
.
├── lower
│   └── lower.txt
├── merge
├── upper
│   └── upper.txt
└── work

$ sudo mount -t overlay overlay -o lowerdir=lower,upperdir=upper,workdir=work merge

$ tree .
.
├── lower
│   └── lower.txt
├── merge
│   ├── lower.txt
│   └── upper.txt
├── upper
│   └── upper.txt
└── work
    └── work
```

When this is applied in container application. The image is lowerdir; container is same as upperdir; and overlay runtime is the merge. 
Now we realise the copy problem mentioned above and the image and container are perfectly seperated.

# Summary

A Container is nothing more than a well isolated process. Actually we didn't "build" any container. Instead we createe a new process and configure it , so that what works inside it "looks like" independent from outside, just behavior like a complete environment. 
